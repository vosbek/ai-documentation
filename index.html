<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Agentic IDE Guide for Developers</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; color: white; margin-bottom: 50px; padding: 40px 0; }
        .header h1 { font-size: 3rem; margin-bottom: 10px; font-weight: 700; }
        .header p { font-size: 1.2rem; opacity: 0.9; }
        .content { background: white; border-radius: 12px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
        .nav { background: #2d3748; padding: 20px; display: flex; gap: 20px; flex-wrap: wrap; }
        .nav-item { background: #4a5568; color: white; padding: 10px 20px; border-radius: 8px; text-decoration: none; transition: all 0.3s; cursor: pointer; }
        .nav-item:hover, .nav-item.active { background: #667eea; transform: translateY(-2px); }
        .section { padding: 40px; display: none; }
        .section.active { display: block; }
        .section h2 { color: #2d3748; margin-bottom: 20px; font-size: 2rem; }
        .section h3 { color: #4a5568; margin: 30px 0 15px 0; font-size: 1.5rem; }
        .principle { background: #f7fafc; border-left: 4px solid #667eea; padding: 20px; margin: 20px 0; border-radius: 0 8px 8px 0; }
        .principle h4 { color: #2d3748; margin-bottom: 10px; }
        .workflow-step { display: flex; align-items: center; margin: 20px 0; padding: 20px; background: #edf2f7; border-radius: 8px; }
        .step-number { background: #667eea; color: white; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; margin-right: 20px; flex-shrink: 0; }
        .code-block { background: #2d3748; color: #e2e8f0; padding: 20px; border-radius: 8px; margin: 20px 0; overflow-x: auto; white-space: pre-wrap; font-family: 'Monaco', 'Menlo', monospace; }
        .template-card { border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; margin: 20px 0; background: #f7fafc; }
        .template-card h4 { color: #2d3748; margin-bottom: 10px; }
        .btn { background: #667eea; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; text-decoration: none; display: inline-block; margin: 10px 10px 10px 0; transition: all 0.3s; }
        .btn:hover { background: #5a67d8; transform: translateY(-1px); }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
        .card { background: white; border: 1px solid #e2e8f0; border-radius: 8px; padding: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .highlight { background: #fed7d7; padding: 2px 6px; border-radius: 4px; color: #c53030; font-weight: 500; }
        .success { background: #c6f6d5; padding: 2px 6px; border-radius: 4px; color: #22543d; font-weight: 500; }
        .video-container { margin: 20px 0; }
        .video-container video { width: 100%; max-width: 800px; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .video-description { margin-top: 10px; padding: 15px; background: #f7fafc; border-radius: 6px; border-left: 4px solid #667eea; }
        .video-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 30px; margin: 30px 0; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>AI Agentic IDE Guide</h1>
            <p>A comprehensive guide for experienced developers transitioning to AI-powered development workflows</p>
        </div>
        
        <div class="content">
            <nav class="nav">
                <a href="#" class="nav-item active" onclick="showSection('mindset')">Mindset Shift</a>
                <a href="#" class="nav-item" onclick="showSection('workflow')">Workflow</a>
                <a href="#" class="nav-item" onclick="showSection('rule-files')">Rule Files & Templates</a>
                <a href="#" class="nav-item" onclick="showSection('prompts')">Agentic Prompts</a>
                <a href="#" class="nav-item" onclick="showSection('tools')">Tool Setup</a>
                <a href="#" class="nav-item" onclick="showSection('cursor-resources')">Cursor Resources</a>
            </nav>
            
            <section id="mindset" class="section active">
                <h2>The Developer's Guide to AI-Powered Coding</h2>
                <p>You're an experienced developer. You understand patterns, architecture, and best practices. Now you need to understand how AI coding tools work and how to leverage them effectively. This isn't about replacing your skills‚Äîit's about amplifying them.</p>
                
                <h3>üß† Core Mental Model Shift</h3>
                
                <div class="principle">
                    <h4>From "Writing Code" to "Directing Code Generation"</h4>
                    <p><strong>Traditional Approach:</strong> You think through the problem, design the solution, and implement it line by line.</p>
                    <p><strong>AI-Powered Approach:</strong> You think through the problem, design the solution, then <strong>communicate that design clearly to AI</strong> and iterate on the results.</p>
                    
                    <div class="code-block"><strong>Example Transformation:</strong>

‚ùå Old way: "I need to build a user authentication system"
‚Üí Spend 2 hours implementing from scratch

‚úÖ New way: "I need to build a user authentication system"
‚Üí "Create auth system following our existing UserService pattern, using JWT tokens, with rate limiting and proper error handling"
‚Üí Review and refine AI output in 30 minutes
‚Üí Spend saved time on complex business logic</div>
                </div>
                
                <div class="principle">
                    <h4>Your New Role: AI Architect & Quality Gate</h4>
                    <p>You're not becoming less technical‚Äîyou're becoming <strong>more strategic</strong>. Your expertise is now focused on higher-leverage activities:</p>
                    
                    <div class="code-block"><strong>High-Value Activities (Your Focus):</strong>
‚Ä¢ System architecture and design decisions
‚Ä¢ Complex business logic and algorithms  
‚Ä¢ Security reviews and performance optimization
‚Ä¢ API design and integration patterns
‚Ä¢ Code quality standards and team mentoring
‚Ä¢ Problem decomposition and requirement analysis

<strong>Low-Value Activities (AI's Focus):</strong>
‚Ä¢ Boilerplate code generation
‚Ä¢ Basic CRUD operations
‚Ä¢ Standard form handling and validation
‚Ä¢ Common utility functions
‚Ä¢ Repetitive test scaffolding
‚Ä¢ Documentation generation</div>
                </div>
                
                <h3>üõ†Ô∏è What AI Coding Tools Actually Do Well</h3>
                
                <div class="workflow-step">
                    <div class="step-number">1</div>
                    <div>
                        <h4>Pattern Recognition & Code Generation</h4>
                        <p><strong>What it means:</strong> AI excels at recognizing patterns in your codebase and generating similar code that follows those patterns.</p>
                        <div class="code-block"><strong>Practical Example:</strong>
You have a UserService.ts with error handling patterns.
AI can generate ProductService.ts, OrderService.ts following the exact same patterns.

<strong>Pro Tip:</strong> Show AI 2-3 examples of your pattern, then ask it to create new instances.</div>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">2</div>
                    <div>
                        <h4>Context-Aware Autocompletion</h4>
                        <p><strong>What it means:</strong> AI understands your entire codebase context and suggests completions that fit your specific project.</p>
                        <div class="code-block"><strong>Practical Example:</strong>
Typing "const user = " in a component that imports useAuth
AI suggests: "const user = useAuth().user" (knows your auth pattern)

<strong>This is not just autocomplete‚Äîit's intelligent code synthesis.</strong></div>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">3</div>
                    <div>
                        <h4>Cross-File Consistency</h4>
                        <p><strong>What it means:</strong> AI can maintain consistency across your entire codebase when making changes.</p>
                        <div class="code-block"><strong>Practical Example:</strong>
You add a "role" field to your User type.
AI can automatically update:
‚Ä¢ Database schema
‚Ä¢ API endpoints
‚Ä¢ Frontend components
‚Ä¢ Test files
‚Ä¢ Documentation

<strong>This prevents the manual hunt-and-update process.</strong></div>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">4</div>
                    <div>
                        <h4>Intelligent Debugging & Code Analysis</h4>
                        <p><strong>What it means:</strong> AI can analyze complex codebases, trace execution paths, and identify issues faster than manual review.</p>
                        <div class="code-block"><strong>Practical Example:</strong>
"This React component is re-rendering too often. Analyze the dependencies and optimize."

AI identifies:
‚Ä¢ Unnecessary useEffect dependencies
‚Ä¢ Missing React.memo opportunities  
‚Ä¢ Object recreation in render
‚Ä¢ Suggests specific optimizations with code</div>
                    </div>
                </div>
                
                <h3>‚ö° Key Concepts Every Developer Must Understand</h3>
                
                <div class="principle">
                    <h4>Concept 1: Context Window & Token Limits</h4>
                    <p><strong>What you need to know:</strong> AI models have limits on how much code they can "see" at once. Understanding this changes how you structure requests.</p>
                    
                    <div class="code-block"><strong>Practical Implications:</strong>

‚úÖ Effective: Open 3-5 relevant files when asking for help
‚ùå Ineffective: Open your entire codebase

‚úÖ Effective: "Look at UserService.ts and create ProductService.ts following the same pattern"
‚ùå Ineffective: "Create a service that follows our patterns" (AI doesn't know your patterns)

<strong>Modern Tools:</strong> Cursor IDE, GitHub Copilot Workspace have smart context management
<strong>Your Job:</strong> Learn to provide optimal context</div>
                </div>
                
                <div class="principle">
                    <h4>Concept 2: Prompt Engineering is a Core Skill</h4>
                    <p><strong>What you need to know:</strong> The quality of your prompts directly determines the quality of AI output. This is a learnable skill with patterns.</p>
                    
                    <div class="code-block"><strong>Effective Prompt Pattern:</strong>

[ROLE] + [CONTEXT] + [SPECIFIC TASK] + [CONSTRAINTS] + [OUTPUT FORMAT]

<strong>Example:</strong>
"Act as a senior React developer [ROLE] 
looking at UserProfile.tsx [CONTEXT]. 
Create a TeamProfile component [TASK] 
that handles role-based permissions and follows our error handling patterns [CONSTRAINTS]. 
Include TypeScript interfaces and Storybook stories [OUTPUT FORMAT]."

<strong>This beats:</strong> "Create a team profile component"</div>
                </div>
                
                <div class="principle">
                    <h4>Concept 3: AI Hallucination & Verification</h4>
                    <p><strong>What you need to know:</strong> AI can confidently suggest code that doesn't work, APIs that don't exist, or solutions that violate your constraints.</p>
                    
                    <div class="code-block"><strong>Common Hallucinations:</strong>
‚Ä¢ Non-existent npm packages or API methods
‚Ä¢ Outdated syntax or deprecated features
‚Ä¢ Solutions that violate your security policies
‚Ä¢ Code that works in theory but fails in your environment

<strong>Your Verification Process:</strong>
1. Does this code actually compile?
2. Do these dependencies exist and work with our setup?
3. Does this follow our security and performance requirements?
4. Are there any obvious logic errors?

<strong>Pro Tip:</strong> Ask AI to explain its reasoning and catch hallucinations early.</div>
                </div>
                
                <div class="principle">
                    <h4>Concept 4: Iterative Refinement Over Perfect First Try</h4>
                    <p><strong>What you need to know:</strong> AI works best through iteration. Don't expect perfect solutions immediately‚Äîplan for 2-3 refinement cycles.</p>
                    
                    <div class="code-block"><strong>Typical Flow:</strong>

Iteration 1: "Create basic user authentication"
‚Üí Get working but basic implementation

Iteration 2: "Add rate limiting and better error handling"
‚Üí Enhanced version with security measures

Iteration 3: "Optimize for performance and add comprehensive tests"
‚Üí Production-ready implementation

<strong>This is faster than trying to specify everything upfront.</strong></div>
                </div>
                
                <h3>üéØ Practical Steps to Get Started Today</h3>
                
                <div class="template-card">
                    <h4>Week 1: Tool Setup & Basic Workflows</h4>
                    <div class="code-block">Day 1-2: Install & Configure
‚Ä¢ Set up Cursor IDE or GitHub Copilot in your existing IDE
‚Ä¢ Create a simple .cursorrules file with your basic patterns
‚Ä¢ Try autocompletion on a small feature

Day 3-4: Basic Prompting
‚Ä¢ Practice context-rich prompts with existing code
‚Ä¢ Try role-based prompting for code reviews
‚Ä¢ Experiment with "explain this code" requests

Day 5-7: Small Features
‚Ä¢ Use AI to generate a complete small feature (form, API endpoint)
‚Ä¢ Focus on providing good context and iterating
‚Ä¢ Review and refactor AI output to match your standards</div>
                </div>
                
                <div class="template-card">
                    <h4>Week 2: Advanced Patterns</h4>
                    <div class="code-block">Day 1-3: Test-Driven Development
‚Ä¢ Write tests first, then ask AI to make them pass
‚Ä¢ Use AI to generate comprehensive test suites
‚Ä¢ Practice TDD with AI for complex business logic

Day 4-5: Cross-File Coordination
‚Ä¢ Use AI to maintain consistency across multiple files
‚Ä¢ Practice full-stack feature development with AI
‚Ä¢ Learn to spot and fix cross-file inconsistencies

Day 6-7: Team Integration
‚Ä¢ Share effective prompts with your team
‚Ä¢ Establish team standards for AI-generated code
‚Ä¢ Create shared rule files and patterns</div>
                </div>
                
                <div class="template-card">
                    <h4>Week 3+: Mastery & Optimization</h4>
                    <div class="code-block">Ongoing Practices:
‚Ä¢ Track which prompts work best for your use cases
‚Ä¢ Develop personal prompt templates for common tasks
‚Ä¢ Use AI for documentation, architecture decisions, and code reviews
‚Ä¢ Integrate AI into your entire development workflow
‚Ä¢ Train team members on effective AI collaboration

<strong>Success Metrics:</strong>
‚Ä¢ 30-50% faster feature development
‚Ä¢ More consistent code quality
‚Ä¢ Better documentation and test coverage
‚Ä¢ More time for complex problem-solving</div>
                </div>
                
                <div class="principle">
                    <h4>üö® Critical Success Factors</h4>
                    <div class="code-block"><strong>Do This:</strong>
‚úÖ Start with small, low-risk features
‚úÖ Always review and test AI-generated code
‚úÖ Maintain your existing code quality standards
‚úÖ Learn from both successes and failures
‚úÖ Share knowledge with your team

<strong>Avoid This:</strong>
‚ùå Blindly trusting AI output without review
‚ùå Using AI for critical security or payment logic without extra scrutiny
‚ùå Expecting perfection on the first try
‚ùå Giving up after a few bad results
‚ùå Skipping proper testing of AI-generated code</div>
                </div>
                
                <h3>üéØ Bottom Line for Smart Developers</h3>
                <p><strong>AI coding tools are force multipliers, not replacements.</strong> Your expertise in system design, debugging, and code quality becomes more valuable, not less. You're adding a powerful new capability to your toolkit that lets you focus on the interesting, complex problems while AI handles the repetitive implementation details.</p>
                
                <p><strong>The developers who master this transition will be significantly more productive and valuable.</strong> The ones who ignore it will find themselves spending time on tasks that others complete in minutes.</p>
                
                <h3>üí° Advanced Prompt Techniques</h3>
                
                <div class="template-card">
                    <h4>Multi-Agent Coordination</h4>
                    <div class="code-block"># MULTI-AGENT COORDINATION PROMPT

## AGENT ROLES
**Primary Agent (You)**: [Architect/Planner] - Responsible for overall strategy and coordination
**Secondary Agents**: Will be assigned specific implementation tasks

## COMPLEX TASK
[Description of multi-faceted task requiring different expertise]

## COORDINATION PROTOCOL

### Phase 1: Task Decomposition (Primary Agent)
1. **Analyze Requirements**: Break down the complex task
2. **Identify Subtasks**: Create specific, focused subtasks
3. **Define Interfaces**: Specify how subtasks will integrate
4. **Assign Expertise**: Determine what specialist knowledge each subtask needs

### Phase 2: Agent Assignment Strategy
For each subtask, specify:
- **Required Expertise**: [Frontend/Backend/Database/DevOps/etc.]
- **Context Files**: @[relevant files for this subtask]
- **Success Criteria**: [How to validate completion]
- **Dependencies**: [What must be completed first]

### Phase 3: Implementation Coordination
1. **Sequence Planning**: Order of execution
2. **Interface Definitions**: How components will connect
3. **Validation Points**: Checkpoints for integration
4. **Rollback Strategy**: How to handle failures

## EXAMPLE WORKFLOW
```
Agent 1 (Database Expert): Design and implement data models
‚îú‚îÄ Input: Requirements and existing schema @[schema.sql]
‚îú‚îÄ Output: Migration scripts and model definitions
‚îî‚îÄ Validation: Schema passes validation tests

Agent 2 (API Expert): Implement backend services
‚îú‚îÄ Input: Data models from Agent 1, API requirements
‚îú‚îÄ Output: REST endpoints with validation
‚îî‚îÄ Validation: API tests pass

Agent 3 (Frontend Expert): Build user interface
‚îú‚îÄ Input: API contracts from Agent 2, design requirements
‚îú‚îÄ Output: React components with state management
‚îî‚îÄ Validation: E2E tests pass

Integration Agent (You): Coordinate and validate complete system
```

## DELIVERABLE
Provide detailed coordination plan with specific subtasks and agent assignments.</div>
                    <button class="btn" onclick="downloadPromptTemplate('multi-agent')">Download Template</button>
                </div>
            </section>
            
            <section id="workflow" class="section">
                <h2>Real-World AI Workflows for Large Codebases</h2>
                <p>Based on proven practices from developers working with production codebases. Modern agentic IDEs like Cursor handle context automatically - your job is to provide the right documentation and guidance.</p>
                
                <h3>üèóÔ∏è Foundation Setup (Do This Once)</h3>
                
                <div class="workflow-step">
                    <div class="step-number">1</div>
                    <div>
                        <h4>Document Your Codebase Patterns</h4>
                        <div class="code-block"><strong>Create Documentation Files (Most Important Step):</strong>

üìÅ <strong>backend-patterns.md</strong> - Explain your backend structure
"Our API endpoints follow this pattern:
- Routes go in /routes/[resource].js
- Services handle business logic in /services/[resource]Service.js  
- Database queries use our custom ORM wrapper in /data/[resource]Repository.js
- Error handling: always use our ApiError class with consistent status codes"

üìÅ <strong>frontend-patterns.md</strong> - Document your UI patterns
"React components follow this structure:
- Use functional components with hooks
- State management with Zustand (not Context API)
- Forms use react-hook-form + zod validation
- Styling with Tailwind following our design system
- Error boundaries wrap all page-level components"

üìÅ <strong>database-patterns.md</strong> - Database conventions
üìÅ <strong>testing-patterns.md</strong> - Testing approach
üìÅ <strong>deployment-patterns.md</strong> - DevOps patterns

<strong>Why This Works:</strong> AI reads these files automatically and follows your patterns without you explaining every time.</div>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">2</div>
                    <div>
                        <h4>Create Smart .cursorrules File</h4>
                        <div class="code-block"><strong>Essential .cursorrules (Copy This):</strong>

# Core Behavior
- Only modify code directly relevant to the specific request
- Never replace code with placeholders - always include complete code
- Break problems into smaller steps before implementing
- Always provide a complete PLAN with REASONING before making changes
- Don't change code randomly, ask if you're not sure

# Project Standards
- Follow patterns in [your-backend-patterns.md]
- Use existing components as examples, don't reinvent
- Reference similar existing files when creating new ones
- Maintain backwards compatibility unless explicitly told otherwise

# Quality Requirements
- Write comprehensive error handling
- Include proper TypeScript types
- Add meaningful tests for new functionality
- Follow our established naming conventions

<strong>Pro Tip:</strong> Reference your pattern files in the rules so AI always checks them.</div>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">3</div>
                    <div>
                        <h4>Set Up Workspace for Context Awareness</h4>
                        <div class="code-block"><strong>Modern IDE Setup:</strong>

‚úÖ <strong>Let Cursor index everything</strong> - Don't manually manage files
‚úÖ <strong>Use @-references</strong> - Type @filename to include specific files
‚úÖ <strong>Keep workspace organized</strong> - AI works better with clean structure
‚úÖ <strong>Use meaningful folder names</strong> - AI understands purpose from structure
‚úÖ <strong>Regular reindexing</strong> - Hit reindex button in Cursor settings periodically

‚ùå <strong>Don't:</strong> Micromanage which files are "open"
‚ùå <strong>Don't:</strong> Close files to "help" the AI
‚ùå <strong>Don't:</strong> Open entire codebase in one workspace

<strong>Key Insight:</strong> Modern AI has context awareness - provide structure, not manual file management.</div>
                    </div>
                </div>
                
                <h3>üéØ Daily Development Workflows</h3>
                
                <div class="template-card">
                    <h4>Workflow 1: Adding New Feature</h4>
                    <div class="code-block"><strong>Step 1: Plan First (Co-write with AI)</strong>
"I need to add user roles functionality. Let's plan this:
- What models/tables need changes?
- Which API endpoints are required?
- What UI components need updates?
- How does this integrate with existing auth?

Create a detailed implementation plan with file list and dependencies."

<strong>Step 2: Point to Existing Patterns</strong>
"Look at how user permissions are handled in @UserService.js and @PermissionMiddleware.js. 
Create the roles system following the same patterns for:
- Database structure
- API design
- Middleware implementation
- Error handling"

<strong>Step 3: Implement One File at a Time</strong>
"Start with the Role model in @models/Role.js. 
Follow the same structure as @models/User.js."

<strong>Step 4: Test Integration</strong>
"Now update @UserService.js to include role checking.
Make sure it integrates properly with existing authentication."

<strong>Success Pattern:</strong> Plan ‚Üí Pattern Reference ‚Üí Small Steps ‚Üí Integration Check</div>
                </div>
                
                <div class="template-card">
                    <h4>Workflow 2: Debugging Complex Issues</h4>
                    <div class="code-block"><strong>Step 1: Provide Complete Context</strong>
"I'm getting [exact error message] when users try to [specific action].

Error occurs in: @ComponentName.tsx
Related files: @ServiceName.js, @types/User.ts
Reproduction: [exact steps]
Browser console: [paste relevant logs]"

<strong>Step 2: Ask for Analysis First</strong>
"Before suggesting fixes, analyze this error:
1. What's the likely root cause?
2. What files are involved in this flow?
3. What should we check first?
4. Are there any related issues to watch for?"

<strong>Step 3: Get Targeted Fix</strong>
"Based on your analysis, provide a specific fix for [the identified issue].
Maintain the existing patterns in @RelatedFile.js.
Explain why this fix addresses the root cause."

<strong>Step 4: Prevent Regression</strong>
"What tests should we add to prevent this issue from happening again?
Create the tests following patterns in @existing.test.js"

<strong>Key Insight:</strong> AI is excellent at analysis when given complete context.</div>
                </div>
                
                <div class="template-card">
                    <h4>Workflow 3: Understanding Legacy Code</h4>
                    <div class="code-block"><strong>Step 1: High-Level Overview</strong>
"Analyze @LegacyComponent.tsx and explain:
1. What is this component's main responsibility?
2. How does it fit into the overall application flow?
3. What are its key dependencies and integrations?
4. What patterns does it follow that I should maintain?"

<strong>Step 2: Specific Function Analysis</strong>
"Focus on the @handleComplexOperation method:
- What does it do step by step?
- What business rules does it implement?
- What are the potential failure points?
- How should I safely modify it?"

<strong>Step 3: Modification Strategy</strong>
"I need to add [specific change]. Based on the existing code:
1. What's the safest approach?
2. Which files need updates?
3. What existing patterns should I follow?
4. What could break and how to prevent it?"

<strong>Pro Tip:</strong> Use AI to understand before modifying - it's excellent at code analysis.</div>
                </div>
                
                <div class="template-card">
                    <h4>Workflow 4: Test-Driven Development</h4>
                    <div class="code-block"><strong>Step 1: Generate Comprehensive Tests</strong>
"Looking at @ExistingService.test.js patterns, create tests for the new UserRoleService:

- Unit tests for all public methods
- Integration tests with database
- Error handling for edge cases
- Performance tests for bulk operations

Follow our testing conventions and use the same mocking patterns."

<strong>Step 2: Implement to Pass Tests</strong>
"I have these failing tests: [paste test file]

Implement UserRoleService to make all tests pass.
Follow the patterns in @UserService.js for:
- Error handling
- Database operations
- Validation logic"

<strong>Step 3: Iterate on Edge Cases</strong>
"The tests are passing but let's add coverage for:
- What happens with invalid role hierarchies?
- How do we handle concurrent role changes?
- What about users with multiple roles?

Add tests and update implementation."

<strong>Success Pattern:</strong> Test First ‚Üí Implement ‚Üí Iterate ‚Üí Verify</div>
                </div>
                
                <h3>‚öôÔ∏è Advanced Workflow Patterns</h3>
                
                <div class="template-card">
                    <h4>Cross-File Coordination (Full-Stack Changes)</h4>
                    <div class="code-block"><strong>For Complex Changes Spanning Multiple Files:</strong>

"I'm adding 'priority' field to Tasks. Update these files maintaining consistency:

1. **Database**: @models/Task.js + migration script
2. **Backend**: @routes/tasks.js API endpoints  
3. **Types**: @types/Task.ts TypeScript definitions
4. **Frontend**: @components/TaskCard.tsx UI updates
5. **Tests**: Update relevant test files

Follow our established patterns for:
- Database field additions (see @models/User.js recent changes)
- API versioning (maintain backwards compatibility)
- Type safety (ensure proper propagation)
- UI updates (follow design system)"

<strong>Key:</strong> AI can coordinate complex changes when given clear structure and references.</div>
                </div>
                
                <div class="template-card">
                    <h4>Code Review and Optimization</h4>
                    <div class="code-block"><strong>Multi-Angle Review Process:</strong>

"Review this @NewFeature.js for production readiness:

**Security Review:**
- Input validation and sanitization
- Authentication/authorization checks
- Potential security vulnerabilities

**Performance Review:**
- Database query efficiency
- Memory usage patterns
- Potential bottlenecks

**Code Quality Review:**
- Follows our established patterns in @backend-patterns.md
- Error handling completeness
- Testing coverage gaps

**Integration Review:**
- Compatibility with existing systems
- Breaking change assessment
- Documentation needs

Provide specific recommendations with code examples."

<strong>Pro Tip:</strong> AI excels at systematic reviews when given clear criteria.</div>
                </div>
                
                <h3>üö® Critical Success Factors</h3>
                
                <div class="principle">
                    <h4>Always Do This</h4>
                    <div class="code-block">‚úÖ **Document your patterns** - Create pattern files that AI can reference
‚úÖ **Plan before coding** - Co-write implementation plans with AI first
‚úÖ **Use existing examples** - Point to similar code rather than explaining
‚úÖ **Control scope** - One function/file at a time for complex changes
‚úÖ **Test AI output** - Always verify code actually works
‚úÖ **Ask for reasoning** - "Explain why you did it this way"
‚úÖ **Maintain rule files** - Update .cursorrules based on what you learn</div>
                </div>
                
                <div class="principle">
                    <h4>Never Do This</h4>
                    <div class="code-block">‚ùå **Don't expect AI to "figure it out"** - Provide clear direction
‚ùå **Don't skip planning** - Jumping straight to code causes problems
‚ùå **Don't trust security-critical code** without extra review
‚ùå **Don't ignore AI errors** - Fix them one by one, don't copy-paste error walls
‚ùå **Don't let codebase get disorganized** - AI needs structure to work well
‚ùå **Don't forget to reindex** - Cursor needs fresh context regularly</div>
                </div>
                
                <h3>üìä What Success Looks Like</h3>
                <div class="code-block"><strong>You'll know these workflows are working when:</strong>

‚Ä¢ **Speed**: 40-60% faster feature development
‚Ä¢ **Quality**: AI suggestions match your patterns consistently  
‚Ä¢ **Confidence**: Less time debugging AI-generated code
‚Ä¢ **Learning**: Better understanding of unfamiliar parts of your codebase
‚Ä¢ **Focus**: More time on architecture, less on boilerplate
‚Ä¢ **Team Consistency**: New developers quickly adopt your patterns

<strong>Key Metric:</strong> You're spending more time reviewing and refining than explaining and correcting.</div>
                
                <h3>üéØ Essential Templates & Rules</h3>
                <p>The documentation-driven approach and smart rule files are what separate effective AI workflows from frustrating ones. Invest time in these foundations and your AI collaboration will transform from "helpful but unpredictable" to "reliable team member."</p>
            </section>
            
            <section id="rule-files" class="section">
                <h2>Modern Rule Files & Templates (2025)</h2>
                <p>Current generation .mdc rule files and modular templates based on the latest agentic IDE best practices. <strong>Note:</strong> .cursorrules files are deprecated - migrate to .mdc format for better control and flexibility.</p>
                
                <h3>üÜï Modern .mdc Rule File Structure</h3>
                
                <div class="template-card">
                    <h4>Foundation .mdc Rule Template</h4>
                    <div class="code-block">---
description: Core development standards and AI behavior
globs: ["**/*"]
alwaysApply: true
---

# You are an expert senior developer with deep understanding of modern software architecture

## AI Behavior Guidelines
- ALWAYS analyze the codebase context before making changes
- Break complex tasks into smaller, manageable steps with clear reasoning
- Reference existing patterns using @filename.ext syntax
- Never use placeholders - provide complete, working code
- Ask clarifying questions if requirements are ambiguous

## Code Quality Standards
- Follow established patterns in @docs/patterns/
- Use TypeScript for type safety across the stack
- Implement comprehensive error handling with proper logging
- Write meaningful tests that cover edge cases
- Optimize for performance and accessibility

## Development Workflow
- Plan implementation approach before coding
- Use existing components and utilities when possible
- Maintain backward compatibility unless explicitly breaking
- Document complex business logic and architectural decisions
- Follow semantic commit conventions for version control</div>
                    <button class="btn" onclick="downloadMDCFile('foundation', 'Foundation Rule')">Download Foundation .mdc</button>
                </div>
                
                <h3>üéØ Technology-Specific .mdc Templates</h3>
                
                <div class="template-card">
                    <h4>React Development (.cursor/rules/react.mdc)</h4>
                    <div class="code-block">---
description: React development patterns and best practices
globs: ["src/**/*.tsx", "src/**/*.jsx", "components/**/*.tsx"]
alwaysApply: false
---

# You are a React expert focused on modern patterns and performance

## Component Architecture
- Use functional components with hooks exclusively
- Implement proper TypeScript interfaces for all props
- Apply React.memo() for components with expensive renders
- Follow composition over inheritance patterns

## State Management Strategy
- `useState` for local component state
- `useReducer` for complex state logic with multiple sub-values
- Zustand for global state (avoid Context API for global state)
- TanStack Query for server state and caching

## Performance Optimization
- Use `useCallback` for event handlers passed to children
- Apply `useMemo` for expensive calculations
- Implement code splitting with React.lazy() for route-level components
- Avoid object creation in render functions

## Error Handling
- Wrap route components with error boundaries
- Use try-catch for async operations in useEffect
- Implement loading and error states for all async operations

## Example Pattern
```tsx
interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

export default React.memo(function UserProfile({ userId, onUpdate }: UserProfileProps) {
  const { data: user, isLoading, error } = useUser(userId);
  
  const handleUpdate = useCallback((data: UserUpdateData) => {
    // Implementation
    onUpdate?.(updatedUser);
  }, [onUpdate]);
  
  if (isLoading) return <UserProfileSkeleton />;
  if (error) return <ErrorMessage error={error} />;
  
  return <UserForm user={user} onSubmit={handleUpdate} />;
});
```

@patterns/react-component-template.tsx</div>
                    <button class="btn" onclick="downloadMDCFile('react', 'React Development')">Download React .mdc</button>
                </div>
                
                <div class="template-card">
                    <h4>API Development (.cursor/rules/api.mdc)</h4>
                    <div class="code-block">---
description: Modern API development with TypeScript and validation
globs: ["src/api/**/*.ts", "src/routes/**/*.ts", "src/services/**/*.ts"]
alwaysApply: false
---

# You are a backend API expert specializing in scalable, secure systems

## API Design Principles
- Follow RESTful conventions with proper HTTP methods
- Implement consistent response formats across all endpoints
- Use OpenAPI/Swagger for API documentation
- Apply proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)

## Request/Response Handling
- Use Zod or similar for request validation and type inference
- Implement middleware for authentication, rate limiting, and CORS
- Return structured error responses with helpful messages
- Support pagination for list endpoints with proper metadata

## Security & Performance
- Validate and sanitize all inputs at the boundary
- Use parameterized queries to prevent SQL injection
- Implement proper authentication (JWT with refresh tokens)
- Add request rate limiting per endpoint
- Use database transactions for multi-step operations

## Error Handling Strategy
- Create custom error classes with specific status codes
- Implement global error middleware for consistent handling
- Log errors with correlation IDs for debugging
- Never expose internal error details to clients

## Example Implementation
```typescript
// src/api/users/routes.ts
import { Router } from 'express';
import { z } from 'zod';
import { validateRequest } from '@/middleware/validation';
import { requireAuth } from '@/middleware/auth';
import { UserService } from './service';

const CreateUserSchema = z.object({
  body: z.object({
    email: z.string().email(),
    name: z.string().min(2).max(50),
    role: z.enum(['user', 'admin']).default('user')
  })
});

const router = Router();

router.post('/users',
  requireAuth,
  validateRequest(CreateUserSchema),
  async (req, res, next) => {
    try {
      const user = await UserService.create(req.body);
      res.status(201).json({
        success: true,
        data: user,
        message: 'User created successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);
```

@patterns/api-endpoint-template.ts</div>
                    <button class="btn" onclick="downloadMDCFile('api', 'API Development')">Download API .mdc</button>
                </div>
                
                <div class="template-card">
                    <h4>Testing Strategy (.cursor/rules/testing.mdc)</h4>
                    <div class="code-block">---
description: Comprehensive testing patterns and TDD approach
globs: ["**/*.test.ts", "**/*.spec.ts", "src/test/**/*.ts"]
alwaysApply: true
---

# You are a testing expert focused on comprehensive coverage and maintainable tests

## Test-Driven Development Approach
- Write tests before implementation (Red-Green-Refactor cycle)
- Use descriptive test names that read like specifications
- Follow the Arrange-Act-Assert (AAA) pattern consistently
- Group related tests with clear describe blocks

## Test Categories & Coverage
- **Unit Tests**: Test individual functions/methods in isolation
- **Integration Tests**: Test interactions between components/services
- **E2E Tests**: Test complete user workflows
- **Contract Tests**: Validate API contracts and data schemas
- Aim for 90%+ code coverage with meaningful assertions

## Modern Testing Patterns
- Use TypeScript for all test files with proper typing
- Implement test factories for consistent test data
- Apply the Builder pattern for complex object creation
- Use property-based testing for edge case discovery

## Mocking & Test Doubles
- Mock external dependencies (APIs, databases, file system)
- Use real implementations for internal modules when feasible
- Create test-specific implementations for complex scenarios
- Reset all mocks between test runs

## Example Test Implementation
```typescript
// UserService.test.ts
import { UserService } from '@/services/UserService';
import { UserRepository } from '@/repositories/UserRepository';
import { createMockUser, createUserFactory } from '@/test/factories';

describe('UserService', () => {
  let userService: UserService;
  let mockRepository: jest.Mocked<UserRepository>;
  
  beforeEach(() => {
    mockRepository = {
      findByEmail: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    } as jest.Mocked<UserRepository>;
    
    userService = new UserService(mockRepository);
  });
  
  describe('createUser', () => {
    it('should create user with valid data and return user without password', async () => {
      // Arrange
      const userData = createUserFactory({ email: 'test@example.com' });
      const expectedUser = createMockUser({ ...userData, id: 'user-123' });
      mockRepository.create.mockResolvedValue(expectedUser);
      
      // Act
      const result = await userService.createUser(userData);
      
      // Assert
      expect(result).toEqual(expect.objectContaining({
        id: 'user-123',
        email: 'test@example.com'
      }));
      expect(result.password).toBeUndefined();
      expect(mockRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({ email: 'test@example.com' })
      );
    });
    
    it('should throw ConflictError when user already exists', async () => {
      // Arrange
      const userData = createUserFactory({ email: 'existing@example.com' });
      mockRepository.findByEmail.mockResolvedValue(createMockUser());
      
      // Act & Assert
      await expect(userService.createUser(userData))
        .rejects.toThrow('User with this email already exists');
      
      expect(mockRepository.create).not.toHaveBeenCalled();
    });
  });
});
```

@patterns/test-template.ts</div>
                    <button class="btn" onclick="downloadMDCFile('testing', 'Testing Strategy')">Download Testing .mdc</button>
                </div>
                
                <h3>üèóÔ∏è Modular Rule System</h3>
                
                <div class="template-card">
                    <h4>Agentic Planning (.cursor/rules/planning.mdc)</h4>
                    <div class="code-block">---
description: Multi-step planning and execution patterns for complex tasks
globs: ["**/*"]
alwaysApply: false
---

# You are an AI planning agent that excels at breaking down complex tasks

## Planning Mode Behavior
- ALWAYS start with a high-level analysis of the requirements
- Break complex tasks into sequential, manageable steps
- Identify dependencies and potential blockers early
- Create implementation plans with clear success criteria

## Analysis Framework
1. **Context Assessment**: Understand existing codebase patterns
2. **Requirement Analysis**: Clarify scope and constraints
3. **Technical Planning**: Choose appropriate tools and approaches
4. **Risk Assessment**: Identify potential issues and mitigation strategies
5. **Implementation Roadmap**: Define step-by-step execution plan

## Communication Pattern
When given a complex task, respond with:

```
## ANALYSIS
[Understanding of the requirements and current state]

## PLAN
### Phase 1: [Description]
- Step 1: [Specific action]
- Step 2: [Specific action]

### Phase 2: [Description] 
- Step 1: [Specific action]
- Step 2: [Specific action]

## DEPENDENCIES
- [List required files, libraries, or external resources]

## RISKS & MITIGATIONS
- Risk: [Potential issue] ‚Üí Mitigation: [How to address]

## SUCCESS CRITERIA
- [How to validate completion]

Shall I proceed with Phase 1?
```

## Execution Guidelines
- Implement one phase at a time
- Validate each step before proceeding
- Adjust plan based on discoveries during implementation
- Always reference existing patterns using @filename.ext</div>
                    <button class="btn" onclick="downloadMDCFile('planning', 'Agentic Planning')">Download Planning .mdc</button>
                </div>
                
                <h3>üìã Complete Rule File Collections</h3>
                
                <div class="grid">
                    <div class="card">
                        <h4>üöÄ Full-Stack React + TypeScript</h4>
                        <p>Complete .mdc rule collection for modern React applications with TypeScript, API integration, and testing</p>
                        <button class="btn" onclick="downloadRuleCollection('react-fullstack')">Download Collection</button>
                    </div>
                    <div class="card">
                        <h4>üêç Python + FastAPI</h4>
                        <p>Professional Python development with FastAPI, async patterns, database integration, and testing</p>
                        <button class="btn" onclick="downloadRuleCollection('python-fastapi')">Download Collection</button>
                    </div>
                    <div class="card">
                        <h4>‚òÅÔ∏è AWS Serverless</h4>
                        <p>Serverless development with AWS Lambda, API Gateway, DynamoDB, and infrastructure as code</p>
                        <button class="btn" onclick="downloadRuleCollection('aws-serverless')">Download Collection</button>
                    </div>
                    <div class="card">
                        <h4>üîÑ DevOps & CI/CD</h4>
                        <p>Complete DevOps workflows with Docker, Kubernetes, GitHub Actions, and monitoring</p>
                        <button class="btn" onclick="downloadRuleCollection('devops-cicd')">Download Collection</button>
                    </div>
                </div>
                
                <h3>üìñ Migration from .cursorrules to .mdc</h3>
                
                <div class="template-card">
                    <h4>Migration Guide & Best Practices</h4>
                    <div class="code-block"># Migrating from .cursorrules to Modern .mdc Rules

## Why Migrate?
- Better organization with multiple rule files
- Conditional application based on file patterns (globs)
- Version control friendly (each rule is a separate file)
- Agent-requested rules for intelligent context switching
- Better IDE integration and rule management

## Migration Process

### Step 1: Create .cursor/rules Directory
```bash
mkdir -p .cursor/rules
```

### Step 2: Split .cursorrules into Focused Files
Break your monolithic .cursorrules into specific concerns:

**Foundation Rule** (.cursor/rules/foundation.mdc)
- Core AI behavior and development standards
- Always applied (alwaysApply: true)

**Technology-Specific Rules**
- .cursor/rules/react.mdc
- .cursor/rules/api.mdc  
- .cursor/rules/database.mdc

**Process Rules**
- .cursor/rules/testing.mdc
- .cursor/rules/security.mdc
- .cursor/rules/performance.mdc

### Step 3: Use Modern .mdc Format
```yaml
---
description: Clear description for agent selection
globs: ["src/**/*.tsx", "components/**/*.jsx"]
alwaysApply: false  # or true for foundation rules
---

# You are an expert [role] with deep knowledge of [domain]

## Context-Specific Guidelines
[Specific instructions for this rule's domain]

## Reference Patterns
@patterns/example-template.tsx
```

### Step 4: Organize by Scope
```
.cursor/rules/
‚îú‚îÄ‚îÄ foundation.mdc          # Always applied
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ react.mdc
‚îÇ   ‚îî‚îÄ‚îÄ styling.mdc
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ api.mdc
‚îÇ   ‚îî‚îÄ‚îÄ database.mdc
‚îî‚îÄ‚îÄ process/
    ‚îú‚îÄ‚îÄ testing.mdc
    ‚îî‚îÄ‚îÄ security.mdc
```

## Best Practices for 2025

1. **Role-Based Instructions**: Start rules with "You are an expert..."
2. **Reference External Files**: Use @filename.ext for pattern examples  
3. **Specific Globs**: Target rules to relevant file types
4. **Modular Design**: Keep rules focused on single concerns
5. **Agent Descriptions**: Write clear descriptions for intelligent rule selection</div>
                    <button class="btn" onclick="downloadMDCFile('migration-guide', 'Migration Guide')">Download Migration Guide</button>
                </div>
                
                <h3>üéØ Ready-to-Use Templates</h3>
                
                <div class="template-card">
                    <h4>Instant Setup Commands</h4>
                    <div class="code-block"># Quick setup for common stacks

# React + TypeScript + Tailwind
curl -L https://your-domain.com/templates/react-ts.zip | tar -xz -C .cursor/rules

# Python + FastAPI + PostgreSQL  
curl -L https://your-domain.com/templates/python-api.zip | tar -xz -C .cursor/rules

# Next.js Full-Stack
curl -L https://your-domain.com/templates/nextjs-fullstack.zip | tar -xz -C .cursor/rules

# Node.js + Express + MongoDB
curl -L https://your-domain.com/templates/node-express.zip | tar -xz -C .cursor/rules</div>
                </div>

            </section>
            
            <section id="prompts" class="section">
                <h2>Agentic Prompt Templates (2025)</h2>
                <p>Structured prompt patterns designed for modern agentic AI systems. These templates follow current best practices from tools like Cursor, Cline, and Bolt.new.</p>
                
                <h3>üß† Core Agentic Patterns</h3>
                
                <div class="template-card">
                    <h4>Planning Mode Prompt (Multi-Step Tasks)</h4>
                    <div class="code-block"># PLANNING MODE

I need you to help implement [FEATURE/TASK DESCRIPTION].

## CONTEXT
- Current codebase: [Brief description]
- Technology stack: [List key technologies]
- Key constraints: [Any limitations or requirements]

## REQUIREMENTS
[Detailed requirements with user stories if applicable]

## INSTRUCTION
Please switch to PLANNING MODE and provide:

1. **ANALYSIS**: What you understand about the current state and requirements
2. **IMPLEMENTATION PLAN**: Break this into phases with specific steps
3. **DEPENDENCIES**: Files, libraries, or resources needed
4. **RISK ASSESSMENT**: Potential issues and how to mitigate them
5. **SUCCESS CRITERIA**: How we'll know it's complete

After I approve the plan, switch to EXECUTION MODE and implement phase by phase.

**Reference Files**: @[list relevant files for context]</div>
                    <button class="btn" onclick="downloadPromptTemplate('planning-mode')">Download Template</button>
                </div>
                
                <div class="template-card">
                    <h4>Role-Based Expert Prompt</h4>
                    <div class="code-block"># EXPERT ROLE ASSIGNMENT

You are a [SPECIFIC ROLE] with 10+ years of experience in [DOMAIN]. You have deep expertise in [SPECIFIC TECHNOLOGIES/PATTERNS].

## YOUR EXPERTISE
- [Key area 1]: [Specific knowledge]
- [Key area 2]: [Specific knowledge] 
- [Key area 3]: [Specific knowledge]

## CURRENT TASK
[Specific task description]

## CONTEXT FILES
@[file1.ts] - [Brief description of relevance]
@[file2.ts] - [Brief description of relevance]

## INSTRUCTIONS
1. **ANALYZE** the current implementation patterns in the context files
2. **IDENTIFY** the best approach based on your expertise
3. **IMPLEMENT** following established patterns and best practices
4. **EXPLAIN** your reasoning and any trade-offs made
5. **SUGGEST** any improvements to existing patterns

## CONSTRAINTS
- Follow patterns established in @[pattern-file]
- Maintain backward compatibility
- [Any other specific constraints]

## OUTPUT FORMAT
Provide complete, working code with explanatory comments where needed.</div>
                    <button class="btn" onclick="downloadPromptTemplate('role-based-expert')">Download Template</button>
                </div>
                
                <div class="template-card">
                    <h4>Chain-of-Thought Analysis Prompt</h4>
                    <div class="code-block"># SYSTEMATIC ANALYSIS REQUEST

## PROBLEM STATEMENT
[Describe the issue or challenge in detail]

## ANALYSIS FRAMEWORK
Please analyze this systematically using the following steps:

### Step 1: Context Understanding
- Review the provided files: @[file1], @[file2], @[file3]
- Identify the current architecture and patterns
- Understand the data flow and dependencies

### Step 2: Root Cause Analysis
- What is the underlying issue?
- What are the contributing factors?
- How does this relate to the broader system?

### Step 3: Solution Evaluation
- What are 2-3 potential approaches?
- What are the pros/cons of each approach?
- Which approach best fits our existing patterns?

### Step 4: Implementation Plan
- What specific changes are needed?
- What files need to be modified?
- What testing is required?

### Step 5: Risk Assessment
- What could go wrong with this approach?
- How can we mitigate these risks?
- What should we monitor after implementation?

## DELIVERABLE
Provide a clear recommendation with implementation code and reasoning.</div>
                    <button class="btn" onclick="downloadPromptTemplate('chain-of-thought')">Download Template</button>
                </div>
                
                <h3>üîß Development Workflow Prompts</h3>
                
                <div class="template-card">
                    <h4>Feature Development Workflow</h4>
                    <div class="code-block"># FEATURE DEVELOPMENT WORKFLOW

## FEATURE SPECIFICATION
**Feature Name**: [Name]
**User Story**: As a [user type], I want to [action] so that [benefit]
**Acceptance Criteria**:
- [ ] [Specific testable criterion 1]
- [ ] [Specific testable criterion 2]
- [ ] [Specific testable criterion 3]

## DEVELOPMENT PHASES

### Phase 1: Architecture & Planning
1. Analyze existing patterns in @[relevant-files]
2. Design data models and API contracts
3. Plan component hierarchy and state management
4. Identify integration points and dependencies

### Phase 2: Backend Implementation
1. Implement data models following @[model-pattern]
2. Create API endpoints following @[api-pattern]
3. Add validation and error handling
4. Write comprehensive tests

### Phase 3: Frontend Implementation
1. Create components following @[component-pattern]
2. Implement state management and API integration
3. Add loading states and error handling
4. Ensure responsive design and accessibility

### Phase 4: Integration & Testing
1. End-to-end testing of the complete workflow
2. Performance testing and optimization
3. Security review and validation
4. Documentation updates

## CONSTRAINTS
- Follow established patterns in @[pattern-files]
- Maintain test coverage above 90%
- Ensure backward compatibility
- [Other project-specific constraints]

## SUCCESS METRICS
- All acceptance criteria met
- Tests passing with appropriate coverage
- Performance benchmarks met
- Code review approved

Please start with Phase 1 and proceed step by step, asking for approval before moving to the next phase.</div>
                    <button class="btn" onclick="downloadPromptTemplate('feature-workflow')">Download Template</button>
                </div>
                
                <div class="template-card">
                    <h4>Code Review & Refactoring Prompt</h4>
                    <div class="code-block"># COMPREHENSIVE CODE REVIEW

## FILES TO REVIEW
@[file1.ts] - [Purpose/context]
@[file2.ts] - [Purpose/context]
@[file3.ts] - [Purpose/context]

## REVIEW DIMENSIONS

### 1. Code Quality
- **Readability**: Clear variable names, logical structure
- **Maintainability**: Proper separation of concerns, modularity
- **Consistency**: Follows established patterns in @[style-guide]
- **Documentation**: Appropriate comments and JSDoc

### 2. Performance
- **Efficiency**: Optimal algorithms and data structures
- **Memory Usage**: No memory leaks, efficient resource management
- **Scalability**: Code can handle increased load
- **Caching**: Appropriate use of memoization and caching

### 3. Security
- **Input Validation**: All inputs properly validated and sanitized
- **Authentication**: Proper access controls
- **Data Exposure**: No sensitive data leaked
- **Vulnerabilities**: No common security flaws

### 4. Testing
- **Coverage**: Adequate test coverage for critical paths
- **Quality**: Tests are meaningful and maintainable
- **Edge Cases**: Important edge cases covered
- **Integration**: Proper integration test coverage

### 5. Architecture
- **Design Patterns**: Appropriate use of established patterns
- **Dependencies**: Minimal and appropriate dependencies
- **Coupling**: Low coupling between modules
- **Cohesion**: High cohesion within modules

## DELIVERABLE FORMAT

### Summary
[High-level assessment of code quality]

### Specific Issues Found
1. **[Category]**: [Issue description]
   - **Location**: [File and line number]
   - **Impact**: [Severity and consequences]
   - **Recommendation**: [How to fix]
   - **Example**: [Code example if helpful]

### Positive Aspects
[What the code does well]

### Refactoring Suggestions
[Broader improvements that could be made]

### Action Items
- [ ] [Specific task 1]
- [ ] [Specific task 2]
- [ ] [Specific task 3]</div>
                    <button class="btn" onclick="downloadPromptTemplate('code-review')">Download Template</button>
                </div>
                
                <h3>üêõ Debugging & Problem Solving</h3>
                
                <div class="template-card">
                    <h4>Advanced Debugging Workflow</h4>
                    <div class="code-block"># SYSTEMATIC DEBUGGING WORKFLOW

## ISSUE DESCRIPTION
**Problem**: [Concise description of the issue]
**Environment**: [Browser, Node version, OS, etc.]
**Reproduction Steps**:
1. [Step 1]
2. [Step 2]
3. [Step 3] - Issue occurs here

**Expected Behavior**: [What should happen]
**Actual Behavior**: [What actually happens]

## ERROR INFORMATION
```
[Paste exact error messages, stack traces, console output]
```

## CONTEXT FILES
@[file1.ts] - [Relevance to the issue]
@[file2.ts] - [Relevance to the issue]
@[file3.ts] - [Relevance to the issue]

## DEBUGGING INSTRUCTIONS

### Phase 1: Analysis
1. **Trace Execution Path**: Follow the code path that leads to the error
2. **Identify Variables**: What data is being processed when the error occurs?
3. **Check Assumptions**: What assumptions might be incorrect?
4. **Review Recent Changes**: What changed recently that might cause this?

### Phase 2: Hypothesis Formation
Based on your analysis, form 2-3 hypotheses about the root cause:
1. **Hypothesis 1**: [Description and reasoning]
2. **Hypothesis 2**: [Description and reasoning]
3. **Hypothesis 3**: [Description and reasoning]

### Phase 3: Investigation
For each hypothesis, suggest specific debugging steps:
- What logs to add?
- What values to inspect?
- What test cases to run?

### Phase 4: Solution
Once the root cause is identified:
1. **Fix**: Implement the solution
2. **Test**: Verify the fix works
3. **Prevent**: Add tests or checks to prevent regression
4. **Document**: Update documentation if needed

## CONSTRAINTS
- Maintain existing API contracts
- Don't break other functionality
- Follow established patterns in @[pattern-files]
- Add appropriate error handling

## DELIVERABLE
Provide:
1. Root cause analysis
2. Complete fix with explanation
3. Test cases to prevent regression
4. Any related improvements</div>
                    <button class="btn" onclick="downloadPromptTemplate('debugging-workflow')">Download Template</button>
                </div>
                
                <h3>üß™ Testing & Quality Assurance</h3>
                
                <div class="template-card">
                    <h4>Comprehensive Testing Strategy</h4>
                    <div class="code-block"># TESTING STRATEGY PROMPT

## TARGET CODE
@[file-to-test.ts] - [Description of functionality]

## TESTING REQUIREMENTS

### Test Categories Needed
- [ ] **Unit Tests**: Test individual functions/methods
- [ ] **Integration Tests**: Test component interactions
- [ ] **E2E Tests**: Test complete user workflows
- [ ] **Performance Tests**: Test under load
- [ ] **Security Tests**: Test for vulnerabilities

## TESTING INSTRUCTIONS

### 1. Analyze the Code
- **Public Interface**: What methods/functions are exposed?
- **Dependencies**: What external services/modules are used?
- **Edge Cases**: What unusual inputs or conditions might occur?
- **Error Conditions**: What can go wrong?

### 2. Design Test Strategy
- **Happy Path Tests**: Normal operation with valid inputs
- **Edge Case Tests**: Boundary conditions and unusual inputs
- **Error Path Tests**: Invalid inputs and error conditions
- **Integration Tests**: How it works with other components

### 3. Implement Tests
Follow the patterns established in @[test-pattern-file]:

```typescript
// Example structure
describe('[ComponentName]', () => {
  describe('[methodName]', () => {
    it('should [expected behavior] when [condition]', async () => {
      // Arrange
      // Act  
      // Assert
    });
  });
});
```

### 4. Test Data Management
- Use factories for creating test data
- Mock external dependencies appropriately
- Clean up after each test

### 5. Coverage Goals
- **Statements**: 95%+
- **Branches**: 90%+
- **Functions**: 100%
- **Lines**: 95%+

## SPECIFIC TEST SCENARIOS
[List any specific scenarios that must be tested based on the functionality]

## CONSTRAINTS
- Follow testing patterns in @[test-patterns]
- Use existing test utilities and mocks
- Tests should run fast (< 100ms each for unit tests)
- Tests should be deterministic and reliable

## DELIVERABLE
Provide complete test suite with:
1. Comprehensive test coverage
2. Clear, descriptive test names
3. Proper setup/teardown
4. Mock implementations where needed
5. Performance assertions where relevant</div>
                    <button class="btn" onclick="downloadPromptTemplate('testing-strategy')">Download Template</button>
                </div>
            </section>
            
            <section id="tools" class="section">
                <h2>Modern Tool Setup & Configuration (2025)</h2>
                <p>Current generation agentic IDE setup with the latest tools and configurations.</p>
                
                <h3>Model Selection Guide</h3>
                <div class="grid">
                    <div class="card">
                        <h4><span class="success">Claude 4 Sonnet</span></h4>
                        <p><strong>Best for:</strong> Architecture decisions, complex reasoning, code review</p>
                        <p><strong>Use when:</strong> Planning features, debugging complex issues</p>
                    </div>
                    <div class="card">
                        <h4><span class="success">Gemini 2.5 Pro</span></h4>
                        <p><strong>Best for:</strong> Fast implementation, large context windows</p>
                        <p><strong>Use when:</strong> Implementing planned features, refactoring</p>
                    </div>
                    <div class="card">
                        <h4><span class="success">GPT-4o</span></h4>
                        <p><strong>Best for:</strong> General coding, quick iterations</p>
                        <p><strong>Use when:</strong> Standard development tasks</p>
                    </div>
                    <div class="card">
                        <h4><span class="success">o3</span></h4>
                        <p><strong>Best for:</strong> Complex algorithms, optimization</p>
                        <p><strong>Use when:</strong> Solving difficult technical challenges</p>
                    </div>
                </div>
                
                <h3>Workspace Organization</h3>
                <div class="code-block">recommended-workspace/
‚îú‚îÄ‚îÄ .cursor/
‚îÇ   ‚îú‚îÄ‚îÄ rules/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ frontend.md
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ backend.md
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ testing.md
‚îÇ   ‚îî‚îÄ‚îÄ mcp-config.json
‚îú‚îÄ‚îÄ .cursorrules
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îî‚îÄ‚îÄ docs/
    ‚îú‚îÄ‚îÄ api-spec.md
    ‚îî‚îÄ‚îÄ architecture.md</div>
            </section>
            
            <section id="cursor-resources" class="section">
                <h2>Cursor Resources</h2>
                <p>Essential Cursor IDE features and capabilities demonstrated through practical examples. These videos show how to maximize your productivity with Cursor's advanced AI-powered development tools.</p>
                
                <div class="video-grid">
                    <div class="video-container">
                        <h3>üìö Documentation Integration</h3>
                        <video controls preload="metadata">
                            <source src="cursordocs.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div class="video-description">
                            <h4>Cursor Documentation Indexing</h4>
                            <p>Learn how Cursor can automatically index and understand any documentation to provide contextually relevant suggestions. This feature allows Cursor to reference your project's docs, API specifications, and external libraries for more accurate code generation.</p>
                            <p><strong>Key Features:</strong></p>
                            <ul>
                                <li>Automatic documentation scanning and indexing</li>
                                <li>Context-aware suggestions based on your docs</li>
                                <li>Integration with external API documentation</li>
                                <li>Smart reference linking in code comments</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="video-container">
                        <h3>üéõÔ∏è Custom Development Modes</h3>
                        <video controls preload="metadata">
                            <source src="custommodes.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div class="video-description">
                            <h4>Cursor Custom Modes</h4>
                            <p>Discover how to create and use custom modes in Cursor to tailor the AI's behavior for specific development contexts. Custom modes allow you to define specialized AI behaviors for different types of work.</p>
                            <p><strong>Key Features:</strong></p>
                            <ul>
                                <li>Creating project-specific AI behavior modes</li>
                                <li>Context switching for different development phases</li>
                                <li>Custom prompt templates and workflows</li>
                                <li>Team-wide mode sharing and standardization</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="video-container">
                        <h3>‚öôÔ∏è Automated Rule Generation</h3>
                        <video controls preload="metadata">
                            <source src="generaterules.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div class="video-description">
                            <h4>Cursor Rule Generation</h4>
                            <p>See how Cursor can automatically analyze your codebase patterns and generate intelligent .cursorrules files. This feature helps maintain consistency across your project by learning from your existing code style and conventions.</p>
                            <p><strong>Key Features:</strong></p>
                            <ul>
                                <li>Automatic pattern recognition from existing code</li>
                                <li>Generation of project-specific rule files</li>
                                <li>Code style and convention enforcement</li>
                                <li>Continuous rule refinement based on feedback</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="video-container">
                        <h3>üìä Mermaid Diagram Generation</h3>
                        <video controls preload="metadata">
                            <source src="mermaid.mp4" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div class="video-description">
                            <h4>Cursor Mermaid Integration</h4>
                            <p>Learn how Cursor can automatically generate Mermaid diagrams from your code structure, helping you visualize system architecture, data flows, and component relationships without manual diagram creation.</p>
                            <p><strong>Key Features:</strong></p>
                            <ul>
                                <li>Automatic code-to-diagram generation</li>
                                <li>Support for flowcharts, sequence diagrams, and entity relationships</li>
                                <li>Real-time diagram updates as code changes</li>
                                <li>Integration with documentation workflows</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <h3>üöÄ Getting Started with These Features</h3>
                
                <div class="template-card">
                    <h4>Quick Setup Guide</h4>
                    <div class="code-block"><strong>1. Enable Documentation Indexing</strong>
‚Ä¢ Go to Cursor Settings ‚Üí Features ‚Üí Documentation
‚Ä¢ Add your project's documentation directories
‚Ä¢ Include external API documentation URLs
‚Ä¢ Wait for indexing to complete (shows in status bar)

<strong>2. Create Custom Modes</strong>
‚Ä¢ Open Command Palette (Ctrl/Cmd + Shift + P)
‚Ä¢ Type "Create Custom Mode"
‚Ä¢ Define mode-specific prompts and behaviors
‚Ä¢ Save and assign keyboard shortcuts

<strong>3. Generate Rules Automatically</strong>
‚Ä¢ Right-click in project root
‚Ä¢ Select "Generate .cursorrules from project"
‚Ä¢ Review and customize generated rules
‚Ä¢ Commit rules file to version control

<strong>4. Enable Mermaid Generation</strong>
‚Ä¢ Install Mermaid extension if not included
‚Ä¢ Use Command Palette ‚Üí "Generate Mermaid from Code"
‚Ä¢ Select diagram type (flowchart, sequence, etc.)
‚Ä¢ Insert generated diagrams into documentation</div>
                </div>
                
                <h3>üí° Best Practices</h3>
                
                <div class="principle">
                    <h4>Documentation Integration Tips</h4>
                    <p>Keep your documentation up-to-date and well-structured. Cursor works best with markdown files, API specs in OpenAPI format, and clear code comments. Organize docs in a logical hierarchy that mirrors your code structure.</p>
                </div>
                
                <div class="principle">
                    <h4>Custom Mode Strategies</h4>
                    <p>Create modes for different development phases: "Planning" mode for architecture discussions, "Implementation" mode for rapid coding, "Review" mode for code analysis, and "Documentation" mode for writing docs and comments.</p>
                </div>
                
                <div class="principle">
                    <h4>Rule File Management</h4>
                    <p>Regularly review and update your generated rules. Start with auto-generated rules as a foundation, then customize them based on team feedback and project evolution. Version control your rules files and share them across your team.</p>
                </div>
                
                <div class="principle">
                    <h4>Diagram Workflow Integration</h4>
                    <p>Generate diagrams early in development to validate architecture decisions. Update diagrams when refactoring major components. Use sequence diagrams for API flows and flowcharts for business logic visualization.</p>
                </div>
                
                <hr style="margin: 40px 0; border: none; border-top: 2px solid #e2e8f0;">
                
                <h2>üìñ Official Cursor Documentation & Guides</h2>
                <p>Comprehensive resources from the Cursor team to help you master every aspect of the IDE. These official guides provide in-depth coverage of features and best practices.</p>
                
                <div class="grid">
                    <div class="card">
                        <h4>üè† Main Documentation</h4>
                        <p>The complete Cursor documentation covering all features, setup, and configuration options.</p>
                        <a href="https://docs.cursor.com/welcome" target="_blank" class="btn">View Docs</a>
                    </div>
                    <div class="card">
                        <h4>üìö Official Guides</h4>
                        <p>Step-by-step tutorials and guides for mastering Cursor's advanced features and workflows.</p>
                        <a href="https://docs.cursor.com/guides" target="_blank" class="btn">Browse Guides</a>
                    </div>
                    <div class="card">
                        <h4>‚å®Ô∏è Keyboard Shortcuts</h4>
                        <p>Complete reference of keyboard shortcuts to speed up your development workflow in Cursor.</p>
                        <a href="https://docs.cursor.com/kbd" target="_blank" class="btn">View Shortcuts</a>
                    </div>
                    <div class="card">
                        <h4>üîÑ Changelog</h4>
                        <p>Stay updated with the latest Cursor features, improvements, and bug fixes.</p>
                        <a href="https://www.cursor.com/ja/changelog" target="_blank" class="btn">View Changelog</a>
                    </div>
                </div>
                
                <h2>‚ö° Advanced Features & Workflows</h2>
                <p>Master Cursor's advanced capabilities for enterprise development and complex projects. These guides cover sophisticated workflows for professional development teams.</p>
                
                <div class="template-card">
                    <h4>üè¢ Working with Large Codebases</h4>
                    <p>Essential strategies for using Cursor effectively in enterprise-scale projects with hundreds of thousands of lines of code. Learn how to maintain performance and accuracy when working with massive repositories.</p>
                    <div class="code-block"><strong>Key Topics Covered:</strong>
‚Ä¢ Optimizing Cursor's indexing for large projects
‚Ä¢ Managing context windows in complex codebases
‚Ä¢ Performance tuning for enterprise environments
‚Ä¢ Best practices for team collaboration on large projects
‚Ä¢ Memory and resource management strategies</div>
                    <a href="https://docs.cursor.com/guides/advanced/large-codebases" target="_blank" class="btn">Read Large Codebase Guide</a>
                </div>
                
                <div class="template-card">
                    <h4>üîå Model Context Protocol (MCP)</h4>
                    <p>Learn how to integrate external tools and services with Cursor using the Model Context Protocol. MCP allows Cursor to work with databases, APIs, and other development tools seamlessly.</p>
                    <div class="code-block"><strong>MCP Capabilities:</strong>
‚Ä¢ Connect to external databases for schema awareness
‚Ä¢ Integrate with REST APIs and GraphQL endpoints
‚Ä¢ Access cloud services and development tools
‚Ä¢ Create custom integrations for your workflow
‚Ä¢ Share context across multiple development environments</div>
                    <a href="https://docs.cursor.com/guides/working-with-context#mcp" target="_blank" class="btn">Learn MCP Integration</a>
                </div>
                
                <div class="template-card">
                    <h4>üí¨ AI-Powered Commit Messages</h4>
                    <p>Automatically generate meaningful, conventional commit messages based on your code changes. This feature analyzes your diffs and creates professional commit messages that follow best practices.</p>
                    <div class="code-block"><strong>Features:</strong>
‚Ä¢ Automatic analysis of code changes
‚Ä¢ Conventional commit format generation
‚Ä¢ Context-aware message creation
‚Ä¢ Support for multiple commit message styles
‚Ä¢ Integration with Git workflow</div>
                    <a href="https://docs.cursor.com/more/ai-commit-message" target="_blank" class="btn">Setup Auto Commit Messages</a>
                </div>
                
                <h2>üé• Community Learning Resources</h2>
                <p>Learn from the community with curated video tutorials, tips, and real-world examples from Cursor users worldwide.</p>
                
                <div class="template-card">
                    <h4>üì∫ Cursor Directory - Video Collection</h4>
                    <p>A comprehensive collection of community-created videos covering various Cursor features, workflows, and use cases. These videos provide practical examples and tips from experienced Cursor users.</p>
                    <div class="code-block"><strong>Video Categories Include:</strong>
‚Ä¢ Getting started tutorials
‚Ä¢ Advanced workflow demonstrations
‚Ä¢ Integration examples with popular frameworks
‚Ä¢ Tips and tricks from power users
‚Ä¢ Real-world project walkthroughs
‚Ä¢ Troubleshooting common issues</div>
                    <a href="https://cursor.directory/learn" target="_blank" class="btn">Browse Community Videos</a>
                </div>
                
                <h2>‚ö†Ô∏è Features Under Development</h2>
                <p><strong>Important:</strong> Some Cursor features are still in development and not recommended for production use.</p>
                
                <div class="template-card" style="border-left: 4px solid #f56565; background: #fed7d7;">
                    <h4>üö´ Background Agents (Preview) - NOT RECOMMENDED</h4>
                    <p><strong class="highlight">‚ö†Ô∏è DO NOT USE IN PRIVACY MODE OR PRODUCTION</strong></p>
                    <p>Background Agents is an experimental feature that's currently in preview. While it shows promise for autonomous development tasks, it's not yet ready for professional use and has significant limitations.</p>
                    <div class="code-block"><strong>Why to Avoid for Now:</strong>
‚ùå Not available in privacy mode
‚ùå Experimental stability and reliability
‚ùå Potential security and privacy concerns
‚ùå May interfere with normal development workflow
‚ùå Limited control over agent actions

<strong>Current Status:</strong>
‚Ä¢ Preview feature only
‚Ä¢ Frequent changes and updates
‚Ä¢ No production support
‚Ä¢ Limited documentation</div>
                    <p><strong>Recommendation:</strong> Wait for the stable release before considering this feature for any serious development work. Focus on the proven features like those shown in the videos above.</p>
                    <a href="https://docs.cursor.com/background-agent" target="_blank" class="btn" style="background: #f56565;">View Preview Docs (Reference Only)</a>
                </div>
                
                <h2>üó∫Ô∏è Learning Path Recommendation</h2>
                <p>Follow this suggested learning path to master Cursor efficiently:</p>
                
                <div class="workflow-step">
                    <div class="step-number">1</div>
                    <div>
                        <h4>Start with the Videos Above</h4>
                        <p>Watch the embedded videos on this page to understand core Cursor capabilities: documentation indexing, custom modes, rule generation, and Mermaid diagrams.</p>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">2</div>
                    <div>
                        <h4>Learn the Basics</h4>
                        <p>Read the <a href="https://docs.cursor.com/welcome" target="_blank">main documentation</a> and memorize key <a href="https://docs.cursor.com/kbd" target="_blank">keyboard shortcuts</a> for efficient navigation.</p>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">3</div>
                    <div>
                        <h4>Explore Advanced Features</h4>
                        <p>Set up <a href="https://docs.cursor.com/more/ai-commit-message" target="_blank">AI commit messages</a> and explore <a href="https://docs.cursor.com/guides/working-with-context#mcp" target="_blank">MCP integrations</a> for your development stack.</p>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">4</div>
                    <div>
                        <h4>Scale to Large Projects</h4>
                        <p>If working with large codebases, implement strategies from the <a href="https://docs.cursor.com/guides/advanced/large-codebases" target="_blank">large codebase guide</a>.</p>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">5</div>
                    <div>
                        <h4>Learn from the Community</h4>
                        <p>Watch <a href="https://cursor.directory/learn" target="_blank">community videos</a> to see real-world usage patterns and discover advanced techniques.</p>
                    </div>
                </div>
                
                <div class="workflow-step">
                    <div class="step-number">6</div>
                    <div>
                        <h4>Stay Updated</h4>
                        <p>Regularly check the <a href="https://www.cursor.com/ja/changelog" target="_blank">changelog</a> for new features and improvements.</p>
                    </div>
                </div>
            </section>
        </div>
    </div>
    
    <script>
        function showSection(sectionId) {
            // Remove active class from all sections and nav items
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
            
            // Add active class to selected section and nav item
            document.getElementById(sectionId).classList.add('active');
            event.target.classList.add('active');
        }
        
        function downloadRuleFile(ruleName) {
            const ruleFiles = {
                'universal': `# Universal Development Rules

## Code Generation Guidelines
* Only modify code directly relevant to the specific request
* Never replace code with placeholders - always include complete code
* Break problems into smaller steps before implementing
* Always provide a complete PLAN with REASONING before making changes
* Explain your OBSERVATIONS clearly, then provide REASONING

## Code Quality Standards
* Write clean, readable code with meaningful variable names
* Include proper error handling and input validation
* Follow established project patterns and conventions
* Add comments for complex business logic only
* Keep functions small and focused on single responsibility

## Testing Requirements  
* Write comprehensive tests for new features
* Include both happy path and error scenarios
* Test integration points and external dependencies
* Use descriptive test names that explain the scenario

## Security Guidelines
* Never hardcode credentials, API keys, or sensitive data
* Validate and sanitize all user inputs
* Use parameterized queries to prevent SQL injection
* Implement proper authentication and authorization`,
                'react': `# React/TypeScript Development Rules

## Technology Stack
* React 18+ with TypeScript
* Next.js 14+ App Router
* Tailwind CSS for styling
* Prisma for database ORM
* tRPC for type-safe APIs

## Component Guidelines
* Use functional components with hooks
* Implement proper TypeScript interfaces for all props
* Use React.memo() for expensive components
* Prefer custom hooks for complex state logic
* Keep components under 200 lines

## State Management
* Use useState for local component state
* Use useReducer for complex state logic
* Implement Zustand for global state when needed
* Use React Query/TanStack Query for server state
* Avoid prop drilling

## API Integration
* Use tRPC for type-safe API calls
* Implement proper loading and error states
* Use React Query for caching and background updates
* Handle optimistic updates appropriately`,
                'angular': `# Angular Development Rules

## Technology Stack
* Angular 15+ with standalone components
* TypeScript with strict mode
* RxJS for reactive programming
* Angular Material for UI components
* NgRx for state management

## Component Guidelines
* Use standalone components by default
* Implement OnPush change detection strategy
* Use reactive forms for form handling
* Follow Angular style guide conventions
* Keep components focused and testable

## Service and State Management
* Use services for business logic
* Implement proper dependency injection
* Use RxJS operators effectively
* Handle subscriptions properly with takeUntil
* Use NgRx for complex state management`,
                'java': `# Java Development Rules

## Technology Stack
* Java 17+ with record types and sealed classes
* Spring Boot 3.x with WebFlux for reactive programming
* Maven for dependency management
* JUnit 5 for testing
* Testcontainers for integration testing

## Code Standards
* Use var for local variables when type is obvious
* Prefer composition over inheritance
* Use immutable objects and records when possible
* Implement proper exception handling
* Follow Java naming conventions

## Spring Boot Best Practices
* Use constructor injection instead of field injection
* Implement proper configuration properties
* Use @Transactional appropriately
* Create proper REST API design
* Implement comprehensive testing strategy`,
                'python': `# Python Development Rules

## Technology Stack
* Python 3.9+ with type hints
* FastAPI for web APIs
* SQLAlchemy 2.0 for ORM
* Pytest for testing
* Pydantic for data validation

## Code Standards
* Follow PEP 8 style guide
* Use type hints for all function signatures
* Implement proper error handling
* Use dataclasses or Pydantic models for data structures
* Keep functions focused and testable

## Async Programming
* Use async/await for I/O operations
* Implement proper async context managers
* Use asyncio for concurrent operations
* Handle async exceptions properly
* Use async generators when appropriate`,
                'javascript-web': `# JavaScript/Web Development Rules

## Technology Stack
* ES2022+ features
* TypeScript for type safety
* Node.js 18+ for backend
* Express.js or Fastify for APIs
* Jest for testing

## Modern JavaScript Standards
* Use const/let instead of var
* Prefer arrow functions for callbacks
* Use template literals for string interpolation
* Implement proper async/await patterns
* Use modules (import/export) consistently

## Web API Best Practices
* Design RESTful APIs with proper HTTP methods
* Implement proper error handling and status codes
* Use middleware for cross-cutting concerns
* Validate input data properly
* Implement rate limiting and security headers`,
                'csharp-dotnet': `# C#/.NET Development Rules

## Technology Stack
* .NET 8+ with minimal APIs
* C# 11+ with nullable reference types
* Entity Framework Core for ORM
* xUnit for testing
* ASP.NET Core for web APIs

## Code Standards
* Use nullable reference types
* Prefer record types for immutable data
* Use pattern matching and switch expressions
* Implement proper async/await patterns
* Follow Microsoft coding conventions

## ASP.NET Core Best Practices
* Use dependency injection container
* Implement proper middleware pipeline
* Use configuration providers
* Create proper API controllers
* Implement comprehensive error handling`,
                'postgresql': `# PostgreSQL Development Rules

## Database Design
* Use proper normalization (3NF minimum)
* Implement foreign key constraints
* Use appropriate data types
* Design efficient indexing strategy
* Use JSONB for semi-structured data

## Performance Optimization
* Use EXPLAIN ANALYZE for query planning
* Implement connection pooling
* Use prepared statements
* Monitor query performance
* Implement proper vacuum and analyze schedules

## Security Best Practices
* Use parameterized queries
* Implement row-level security when needed
* Use proper user permissions
* Enable SSL connections
* Regular security updates`,
                'oracle': `# Oracle Database Development Rules

## Database Design
* Use proper schema design with tablespaces
* Implement proper indexing strategies
* Use Oracle-specific features appropriately
* Design for high availability
* Implement proper backup strategies

## PL/SQL Best Practices
* Use exception handling properly
* Implement bulk operations for performance
* Use cursor FOR loops appropriately
* Handle implicit and explicit cursors correctly
* Use proper package design

## Performance Tuning
* Use Oracle optimizer hints judiciously
* Monitor using AWR reports
* Implement proper statistics gathering
* Use partitioning for large tables
* Regular performance monitoring`,
                'aws': `# AWS Development Rules

## Infrastructure as Code
* Use CloudFormation or CDK for infrastructure
* Implement proper tagging strategies
* Use least privilege principle for IAM
* Design for multiple availability zones
* Implement cost optimization strategies

## Serverless Best Practices
* Use Lambda for event-driven architecture
* Implement proper error handling and retries
* Use environment variables for configuration
* Monitor with CloudWatch
* Implement proper security practices

## Security and Compliance
* Enable CloudTrail for auditing
* Use AWS Config for compliance
* Implement proper encryption
* Use VPC for network security
* Regular security assessments`,
                'kubernetes': `# Kubernetes Development Rules

## Resource Management
* Use proper resource requests and limits
* Implement horizontal pod autoscaling
* Use namespaces for resource isolation
* Implement proper RBAC
* Use network policies for security

## Deployment Best Practices
* Use rolling updates for deployments
* Implement health checks and readiness probes
* Use ConfigMaps and Secrets for configuration
* Implement proper logging and monitoring
* Use Helm for package management

## Security and Monitoring
* Use Pod Security Standards
* Implement network segmentation
* Monitor with Prometheus and Grafana
* Use service mesh for complex communications
* Regular security scanning`,
                'docker': `# Docker Development Rules

## Container Design
* Use multi-stage builds for optimization
* Keep images small and focused
* Use non-root users for security
* Implement proper health checks
* Use .dockerignore to exclude unnecessary files

## Security Best Practices
* Use official base images
* Regularly update base images
* Scan images for vulnerabilities
* Use secrets management
* Implement proper access controls

## Performance Optimization
* Optimize layer caching
* Use appropriate base images
* Minimize image size
* Use proper resource constraints
* Monitor container performance`,
                'terraform': `# Terraform Development Rules

## Infrastructure as Code
* Use modules for reusable components
* Implement proper state management
* Use remote state backends
* Implement proper versioning
* Use workspaces for environment separation

## Security Best Practices
* Use least privilege principle
* Implement proper secret management
* Use policy as code with Sentinel
* Regular security scanning
* Implement proper access controls

## Code Organization
* Structure code with modules
* Use proper naming conventions
* Implement comprehensive documentation
* Use version constraints
* Implement proper testing strategies`,
                'cicd': `# CI/CD Pipeline Development Rules

## Pipeline Design Principles
* Design pipelines as code (Jenkins Pipeline, GitHub Actions, GitLab CI)
* Implement fail-fast strategies with early validation
* Use parallel execution where possible to reduce build times
* Implement proper pipeline versioning and rollback capabilities
* Design for idempotency - pipelines should be repeatable

## Source Control Integration
* Trigger builds on every commit to main/master branch
* Use pull request/merge request builds for validation
* Implement proper branching strategies (GitFlow, GitHub Flow)
* Use semantic versioning for releases
* Tag releases automatically in source control

## Testing Strategy
* Run unit tests in early pipeline stages
* Implement integration testing in isolated environments
* Use smoke tests for quick validation
* Run security scanning and vulnerability assessment
* Implement performance testing for critical paths

## Deployment Best Practices
* Use blue-green or canary deployment strategies
* Implement proper rollback mechanisms
* Use infrastructure as code for environment provisioning
* Implement proper environment promotion
* Use feature flags for controlled rollouts`,
                'scripting': `# Scripting and Automation Rules (Bash/Perl/PowerShell)

## Bash Scripting Standards
* Use proper shebang: #!/bin/bash
* Enable strict mode: set -euo pipefail
* Quote all variables to prevent word splitting: "$variable"
* Use meaningful variable names in UPPER_CASE for globals
* Implement proper error handling with trap

## Bash Best Practices
* Use [[ ]] for conditional tests instead of [ ]
* Use $(command) instead of backticks for command substitution
* Check for required commands with command -v
* Use arrays for lists: files=("file1" "file2")
* Implement proper logging with timestamps

## PowerShell Standards
* Use approved verbs for function names (Get-, Set-, New-, etc.)
* Implement proper parameter validation
* Use Write-Output instead of Write-Host for data
* Handle errors with try/catch blocks
* Use pipeline efficiently

## General Scripting Principles
* Make scripts idempotent when possible
* Implement proper argument parsing
* Use configuration files for complex settings
* Implement comprehensive logging
* Test scripts in isolated environments first`,
                'README': `# Rule File Builder Guide

## How to Use Rule File Snippets

The rule files in this directory are modular snippets that can be combined to create custom .cursorrules files for your specific project needs.

## Building Your Custom .cursorrules File

### 1. Start with Universal Rules
Always begin with the universal rules as your foundation

### 2. Add Language-Specific Rules
Append rules for your primary programming language

### 3. Add Infrastructure Rules
Include relevant infrastructure and deployment rules

### 4. Add Database Rules
Include database-specific rules

## Example Combinations

### Full-Stack Web Application
Universal + React + JavaScript + PostgreSQL + AWS + Docker + CI/CD

### Enterprise Java Application
Universal + Java + Oracle + Kubernetes + CI/CD

### Python Data Science Project
Universal + Python + Snowflake + AWS + Docker

## Customization Tips

1. Remove rules that don't apply to your project
2. Add project-specific patterns and conventions
3. Include references to your existing codebase
4. Update rules based on team feedback
5. Keep rules practical and actionable

## Maintenance

- Review and update rules quarterly
- Add new patterns as they emerge
- Remove outdated practices
- Get team consensus on major changes
- Document rule rationale for complex decisions`
            };
            
            const fileContent = ruleFiles[ruleName];
            if (!fileContent) {
                console.error('Rule file not found:', ruleName);
                return;
            }
            
            downloadFile(`${ruleName}.md`, fileContent);
        }
        
        function downloadStackRules(stackName) {
            const stacks = {
                'react-stack': {
                    name: 'Full-Stack React',
                    rules: ['universal', 'react', 'javascript-web', 'postgresql', 'aws', 'docker', 'cicd']
                },
                'java-stack': {
                    name: 'Enterprise Java',
                    rules: ['universal', 'java', 'oracle', 'kubernetes', 'cicd']
                },
                'python-stack': {
                    name: 'Python Data/API',
                    rules: ['universal', 'python', 'postgresql', 'aws', 'docker']
                },
                'angular-stack': {
                    name: 'Angular Enterprise',
                    rules: ['universal', 'angular', 'csharp-dotnet', 'postgresql', 'aws', 'kubernetes']
                }
            };
            
            const stack = stacks[stackName];
            if (!stack) {
                console.error('Stack not found:', stackName);
                return;
            }
            
            let combinedRules = `# ${stack.name} Development Rules\n`;
            combinedRules += `# Generated stack with: ${stack.rules.join(', ')}\n\n`;
            
            // Placeholder content for demo - in real implementation, would combine actual rule files
            combinedRules += `# This is a combined rule file for ${stack.name} development\n`;
            combinedRules += `# Contains rules for: ${stack.rules.join(', ')}\n\n`;
            combinedRules += `# Add your project-specific customizations below\n`;
            
            downloadFile(`${stackName}.cursorrules`, combinedRules);
        }
        
        function downloadTemplate(type) {
            const templates = {
                feature: `# Feature: [Feature Name]

## User Goal
[What the user wants to accomplish]

## Data Models
[Required data structures and relationships]

## API Requirements
- Endpoint: [method] /api/[path]
- Input: [request format]
- Output: [response format]
- Business Logic: [key processing steps]

## UI Components
- [Component name]: [purpose and behavior]
- [State management requirements]

## Acceptance Criteria
- [ ] [Specific testable requirement]
- [ ] [Another requirement]

## References
Similar implementation: [path/to/similar/file.ts]`,
                bug: `# Bug Report: [Issue Description]

## Current Behavior
[What's happening now]

## Expected Behavior
[What should happen]

## Steps to Reproduce
1. [Step 1]
2. [Step 2]
3. [Error occurs]

## Error Details
\`\`\`
[Error message/stack trace]
\`\`\`

## Affected Files
- [file1.ts]: [what's wrong]
- [file2.ts]: [related issue]

## Investigation Plan
1. [First thing to check]
2. [Second thing to check]
3. [Test to verify fix]`,
                review: `# AI Code Review Checklist

## Functionality
- [ ] Does the code solve the intended problem?
- [ ] Are edge cases handled?
- [ ] Is error handling appropriate?

## Security & Safety
- [ ] No hardcoded credentials or secrets
- [ ] Input validation in place
- [ ] SQL injection prevention
- [ ] XSS prevention measures

## Performance
- [ ] No unnecessary loops or operations
- [ ] Database queries optimized
- [ ] Memory usage reasonable

## Maintainability
- [ ] Code follows established patterns
- [ ] Variable/function names are clear
- [ ] Comments explain complex logic
- [ ] No code duplication

## Testing
- [ ] Tests cover happy path
- [ ] Tests cover error scenarios
- [ ] Integration points tested`
            };
            
            downloadFile(`${type}-template.md`, templates[type]);
        }
        
        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
        
        function downloadMDCFile(ruleType, description) {
            const mdcTemplates = {
                'foundation': `---
description: Core development standards and AI behavior
globs: ["**/*"]
alwaysApply: true
---

# You are an expert senior developer with deep understanding of modern software architecture

## AI Behavior Guidelines
- ALWAYS analyze the codebase context before making changes
- Break complex tasks into smaller, manageable steps with clear reasoning
- Reference existing patterns using @filename.ext syntax
- Never use placeholders - provide complete, working code
- Ask clarifying questions if requirements are ambiguous

## Code Quality Standards
- Follow established patterns in @docs/patterns/
- Use TypeScript for type safety across the stack
- Implement comprehensive error handling with proper logging
- Write meaningful tests that cover edge cases
- Optimize for performance and accessibility

## Development Workflow
- Plan implementation approach before coding
- Use existing components and utilities when possible
- Maintain backward compatibility unless explicitly breaking
- Document complex business logic and architectural decisions
- Follow semantic commit conventions for version control`,
                'react': `---
description: React development patterns and best practices
globs: ["src/**/*.tsx", "src/**/*.jsx", "components/**/*.tsx"]
alwaysApply: false
---

# You are a React expert focused on modern patterns and performance

## Component Architecture
- Use functional components with hooks exclusively
- Implement proper TypeScript interfaces for all props
- Apply React.memo() for components with expensive renders
- Follow composition over inheritance patterns

## State Management Strategy
- useState for local component state
- useReducer for complex state logic with multiple sub-values
- Zustand for global state (avoid Context API for global state)
- TanStack Query for server state and caching

## Performance Optimization
- Use useCallback for event handlers passed to children
- Apply useMemo for expensive calculations
- Implement code splitting with React.lazy() for route-level components
- Avoid object creation in render functions

## Error Handling
- Wrap route components with error boundaries
- Use try-catch for async operations in useEffect
- Implement loading and error states for all async operations

@patterns/react-component-template.tsx`,
                'api': `---
description: Modern API development with TypeScript and validation
globs: ["src/api/**/*.ts", "src/routes/**/*.ts", "src/services/**/*.ts"]
alwaysApply: false
---

# You are a backend API expert specializing in scalable, secure systems

## API Design Principles
- Follow RESTful conventions with proper HTTP methods
- Implement consistent response formats across all endpoints
- Use OpenAPI/Swagger for API documentation
- Apply proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)

## Request/Response Handling
- Use Zod or similar for request validation and type inference
- Implement middleware for authentication, rate limiting, and CORS
- Return structured error responses with helpful messages
- Support pagination for list endpoints with proper metadata

## Security & Performance
- Validate and sanitize all inputs at the boundary
- Use parameterized queries to prevent SQL injection
- Implement proper authentication (JWT with refresh tokens)
- Add request rate limiting per endpoint
- Use database transactions for multi-step operations

@patterns/api-endpoint-template.ts`,
                'testing': `---
description: Comprehensive testing patterns and TDD approach
globs: ["**/*.test.ts", "**/*.spec.ts", "src/test/**/*.ts"]
alwaysApply: true
---

# You are a testing expert focused on comprehensive coverage and maintainable tests

## Test-Driven Development Approach
- Write tests before implementation (Red-Green-Refactor cycle)
- Use descriptive test names that read like specifications
- Follow the Arrange-Act-Assert (AAA) pattern consistently
- Group related tests with clear describe blocks

## Test Categories & Coverage
- Unit Tests: Test individual functions/methods in isolation
- Integration Tests: Test interactions between components/services
- E2E Tests: Test complete user workflows
- Contract Tests: Validate API contracts and data schemas
- Aim for 90%+ code coverage with meaningful assertions

## Modern Testing Patterns
- Use TypeScript for all test files with proper typing
- Implement test factories for consistent test data
- Apply the Builder pattern for complex object creation
- Use property-based testing for edge case discovery

@patterns/test-template.ts`,
                'planning': `---
description: Multi-step planning and execution patterns for complex tasks
globs: ["**/*"]
alwaysApply: false
---

# You are an AI planning agent that excels at breaking down complex tasks

## Planning Mode Behavior
- ALWAYS start with a high-level analysis of the requirements
- Break complex tasks into sequential, manageable steps
- Identify dependencies and potential blockers early
- Create implementation plans with clear success criteria

## Analysis Framework
1. Context Assessment: Understand existing codebase patterns
2. Requirement Analysis: Clarify scope and constraints
3. Technical Planning: Choose appropriate tools and approaches
4. Risk Assessment: Identify potential issues and mitigation strategies
5. Implementation Roadmap: Define step-by-step execution plan

## Communication Pattern
When given a complex task, respond with structured analysis and plan`,
                'migration-guide': `# Migrating from .cursorrules to Modern .mdc Rules

## Why Migrate?
- Better organization with multiple rule files
- Conditional application based on file patterns (globs)
- Version control friendly (each rule is a separate file)
- Agent-requested rules for intelligent context switching
- Better IDE integration and rule management

## Migration Process

### Step 1: Create .cursor/rules Directory
\`\`\`bash
mkdir -p .cursor/rules
\`\`\`

### Step 2: Split .cursorrules into Focused Files
Break your monolithic .cursorrules into specific concerns:

**Foundation Rule** (.cursor/rules/foundation.mdc)
- Core AI behavior and development standards
- Always applied (alwaysApply: true)

**Technology-Specific Rules**
- .cursor/rules/react.mdc
- .cursor/rules/api.mdc  
- .cursor/rules/database.mdc

**Process Rules**
- .cursor/rules/testing.mdc
- .cursor/rules/security.mdc
- .cursor/rules/performance.mdc`
            };
            
            const content = mdcTemplates[ruleType];
            if (content) {
                downloadFile(`${ruleType}.mdc`, content);
            } else {
                console.error('Template not found:', ruleType);
            }
        }
        
        function downloadPromptTemplate(templateType) {
            const promptTemplates = {
                'planning-mode': `# PLANNING MODE

I need you to help implement [FEATURE/TASK DESCRIPTION].

## CONTEXT
- Current codebase: [Brief description]
- Technology stack: [List key technologies]
- Key constraints: [Any limitations or requirements]

## REQUIREMENTS
[Detailed requirements with user stories if applicable]

## INSTRUCTION
Please switch to PLANNING MODE and provide:

1. **ANALYSIS**: What you understand about the current state and requirements
2. **IMPLEMENTATION PLAN**: Break this into phases with specific steps
3. **DEPENDENCIES**: Files, libraries, or resources needed
4. **RISK ASSESSMENT**: Potential issues and how to mitigate them
5. **SUCCESS CRITERIA**: How we'll know it's complete

After I approve the plan, switch to EXECUTION MODE and implement phase by phase.

**Reference Files**: @[list relevant files for context]`,
                'role-based-expert': `# EXPERT ROLE ASSIGNMENT

You are a [SPECIFIC ROLE] with 10+ years of experience in [DOMAIN]. You have deep expertise in [SPECIFIC TECHNOLOGIES/PATTERNS].

## YOUR EXPERTISE
- [Key area 1]: [Specific knowledge]
- [Key area 2]: [Specific knowledge] 
- [Key area 3]: [Specific knowledge]

## CURRENT TASK
[Specific task description]

## CONTEXT FILES
@[file1.ts] - [Brief description of relevance]
@[file2.ts] - [Brief description of relevance]

## INSTRUCTIONS
1. **ANALYZE** the current implementation patterns in the context files
2. **IDENTIFY** the best approach based on your expertise
3. **IMPLEMENT** following established patterns and best practices
4. **EXPLAIN** your reasoning and any trade-offs made
5. **SUGGEST** any improvements to existing patterns

## CONSTRAINTS
- Follow patterns established in @[pattern-file]
- Maintain backward compatibility
- [Any other specific constraints]

## OUTPUT FORMAT
Provide complete, working code with explanatory comments where needed.`,
                'chain-of-thought': `# SYSTEMATIC ANALYSIS REQUEST

## PROBLEM STATEMENT
[Describe the issue or challenge in detail]

## ANALYSIS FRAMEWORK
Please analyze this systematically using the following steps:

### Step 1: Context Understanding
- Review the provided files: @[file1], @[file2], @[file3]
- Identify the current architecture and patterns
- Understand the data flow and dependencies

### Step 2: Root Cause Analysis
- What is the underlying issue?
- What are the contributing factors?
- How does this relate to the broader system?

### Step 3: Solution Evaluation
- What are 2-3 potential approaches?
- What are the pros/cons of each approach?
- Which approach best fits our existing patterns?

### Step 4: Implementation Plan
- What specific changes are needed?
- What files need to be modified?
- What testing is required?

### Step 5: Risk Assessment
- What could go wrong with this approach?
- How can we mitigate these risks?
- What should we monitor after implementation?

## DELIVERABLE
Provide a clear recommendation with implementation code and reasoning.`,
                'feature-workflow': `# FEATURE DEVELOPMENT WORKFLOW

## FEATURE SPECIFICATION
**Feature Name**: [Name]
**User Story**: As a [user type], I want to [action] so that [benefit]
**Acceptance Criteria**:
- [ ] [Specific testable criterion 1]
- [ ] [Specific testable criterion 2]
- [ ] [Specific testable criterion 3]

## DEVELOPMENT PHASES

### Phase 1: Architecture & Planning
1. Analyze existing patterns in @[relevant-files]
2. Design data models and API contracts
3. Plan component hierarchy and state management
4. Identify integration points and dependencies

### Phase 2: Backend Implementation
1. Implement data models following @[model-pattern]
2. Create API endpoints following @[api-pattern]
3. Add validation and error handling
4. Write comprehensive tests

### Phase 3: Frontend Implementation
1. Create components following @[component-pattern]
2. Implement state management and API integration
3. Add loading states and error handling
4. Ensure responsive design and accessibility

### Phase 4: Integration & Testing
1. End-to-end testing of the complete workflow
2. Performance testing and optimization
3. Security review and validation
4. Documentation updates

Please start with Phase 1 and proceed step by step, asking for approval before moving to the next phase.`,
                'code-review': `# COMPREHENSIVE CODE REVIEW

## FILES TO REVIEW
@[file1.ts] - [Purpose/context]
@[file2.ts] - [Purpose/context]
@[file3.ts] - [Purpose/context]

## REVIEW DIMENSIONS

### 1. Code Quality
- **Readability**: Clear variable names, logical structure
- **Maintainability**: Proper separation of concerns, modularity
- **Consistency**: Follows established patterns in @[style-guide]
- **Documentation**: Appropriate comments and JSDoc

### 2. Performance
- **Efficiency**: Optimal algorithms and data structures
- **Memory Usage**: No memory leaks, efficient resource management
- **Scalability**: Code can handle increased load
- **Caching**: Appropriate use of memoization and caching

### 3. Security
- **Input Validation**: All inputs properly validated and sanitized
- **Authentication**: Proper access controls
- **Data Exposure**: No sensitive data leaked
- **Vulnerabilities**: No common security flaws

## DELIVERABLE FORMAT
Provide specific issues found with recommendations and action items.`,
                'debugging-workflow': `# SYSTEMATIC DEBUGGING WORKFLOW

## ISSUE DESCRIPTION
**Problem**: [Concise description of the issue]
**Environment**: [Browser, Node version, OS, etc.]
**Reproduction Steps**:
1. [Step 1]
2. [Step 2]
3. [Step 3] - Issue occurs here

**Expected Behavior**: [What should happen]
**Actual Behavior**: [What actually happens]

## ERROR INFORMATION
\`\`\`
[Paste exact error messages, stack traces, console output]
\`\`\`

## DEBUGGING INSTRUCTIONS

### Phase 1: Analysis
1. **Trace Execution Path**: Follow the code path that leads to the error
2. **Identify Variables**: What data is being processed when the error occurs?
3. **Check Assumptions**: What assumptions might be incorrect?
4. **Review Recent Changes**: What changed recently that might cause this?

### Phase 2: Hypothesis Formation
Based on your analysis, form 2-3 hypotheses about the root cause

### Phase 3: Investigation
For each hypothesis, suggest specific debugging steps

### Phase 4: Solution
Once the root cause is identified, implement and test the fix.`,
                'testing-strategy': `# TESTING STRATEGY PROMPT

## TARGET CODE
@[file-to-test.ts] - [Description of functionality]

## TESTING REQUIREMENTS

### Test Categories Needed
- [ ] **Unit Tests**: Test individual functions/methods
- [ ] **Integration Tests**: Test component interactions
- [ ] **E2E Tests**: Test complete user workflows
- [ ] **Performance Tests**: Test under load
- [ ] **Security Tests**: Test for vulnerabilities

## TESTING INSTRUCTIONS

### 1. Analyze the Code
- **Public Interface**: What methods/functions are exposed?
- **Dependencies**: What external services/modules are used?
- **Edge Cases**: What unusual inputs or conditions might occur?
- **Error Conditions**: What can go wrong?

### 2. Design Test Strategy
- **Happy Path Tests**: Normal operation with valid inputs
- **Edge Case Tests**: Boundary conditions and unusual inputs
- **Error Path Tests**: Invalid inputs and error conditions
- **Integration Tests**: How it works with other components

### 3. Implement Tests
Follow the patterns established in @[test-pattern-file]

## DELIVERABLE
Provide complete test suite with comprehensive coverage.`,
                'multi-agent': `# MULTI-AGENT COORDINATION PROMPT

## AGENT ROLES
**Primary Agent (You)**: [Architect/Planner] - Responsible for overall strategy and coordination
**Secondary Agents**: Will be assigned specific implementation tasks

## COMPLEX TASK
[Description of multi-faceted task requiring different expertise]

## COORDINATION PROTOCOL

### Phase 1: Task Decomposition (Primary Agent)
1. **Analyze Requirements**: Break down the complex task
2. **Identify Subtasks**: Create specific, focused subtasks
3. **Define Interfaces**: Specify how subtasks will integrate
4. **Assign Expertise**: Determine what specialist knowledge each subtask needs

### Phase 2: Agent Assignment Strategy
For each subtask, specify:
- **Required Expertise**: [Frontend/Backend/Database/DevOps/etc.]
- **Context Files**: @[relevant files for this subtask]
- **Success Criteria**: [How to validate completion]
- **Dependencies**: [What must be completed first]

### Phase 3: Implementation Coordination
1. **Sequence Planning**: Order of execution
2. **Interface Definitions**: How components will connect
3. **Validation Points**: Checkpoints for integration
4. **Rollback Strategy**: How to handle failures

## DELIVERABLE
Provide detailed coordination plan with specific subtasks and agent assignments.`
            };
            
            const content = promptTemplates[templateType];
            if (content) {
                downloadFile(`${templateType}-prompt-template.md`, content);
            } else {
                console.error('Prompt template not found:', templateType);
            }
        }
        
        function downloadRuleCollection(collectionType) {
            const collections = {
                'react-fullstack': 'Complete React + TypeScript + Node.js rule collection with foundation, React, API, testing, and deployment rules.',
                'python-fastapi': 'Professional Python development with FastAPI, async patterns, database integration, and comprehensive testing.',
                'aws-serverless': 'Serverless development with AWS Lambda, API Gateway, DynamoDB, and infrastructure as code patterns.',
                'devops-cicd': 'Complete DevOps workflows with Docker, Kubernetes, GitHub Actions, monitoring, and security practices.'
            };
            
            const description = collections[collectionType];
            if (description) {
                // In a real implementation, this would download a zip file with multiple .mdc files
                alert(`${collectionType} collection download would start here. This collection includes: ${description}`);
            } else {
                console.error('Collection not found:', collectionType);
            }
        }
    </script>
</body>
</html>